# 上下文无关语言
[![Github link](https://img.shields.io/badge/FaDrYL--blue?style=social&logo=Github&logoWidth=15)](https://github.com/FaDrYL)
[![Website link](https://img.shields.io/badge/FaDr-YL-blue?style=flat&color=009f9f)](https://www.fadryl.com/)

**Context-Free Language (CFL)**  
上下文无关语言是以[上下文无关文法](#上下文无关文法（CFG）)定义的语言。
                          
<br/>

## 上下文无关文法（CFG）
**Context-Free Grammar**  
上下文无关文法由一条条的规则组成。

一条简单的上下文无关文法规则：`S -> aSa`

- 大写字母为**非终结**符，
- 小写字母为**终结**符，
- 箭头的左边为一个非终结符，
- 箭头的右边为一些终结符或非终结符。
- 左边能生成右边。

> 正则文法（Regular Grammar）  
> 所有的正则语言都可以由正则文法产生。    
> 正则文法的规则:  
> 1. `非终结符 -> 一些终结符，结尾为一个非终结符` （如：`S -> aaaS`），或者
> 2. `非终结符 -> 一些终结符` （如：`S -> a`）。

### 例子
对于语言“回文”，字母表为 {a,b}。  
我们能写出一些CFG，如这个：

```
S -> aSa          (1)
S -> bSb          (2)
S -> a            (3)
S -> b            (4)
S -> Ɛ            (5) 
```

<br/>

> 如何用这个 CFG 去解析字符串 "aaabaaa" 呢？

```
从一个 'S' 开始.
S -> aSa         (对S运用规则1)
  -> aaSaa       (对S运用规则1)
  -> aaaSaaa     (对S运用规则1)
  -> aaabaaa     (对S运用规则4)
完成!
```

<br/>

## 解析树
**Parse Tree**  
解析树是个用于解析字符串的树结构。

### 例子
对于语言“回文”，字母表为 {a,b}。  
我们用之前的CFG：
```
S -> aSa          (1)
S -> bSb          (2)
S -> a            (3)
S -> b            (4)
S -> Ɛ            (5) 
```

> "aaabaaa" 的解析树

```
            S
          / | \       (规则 1)
         a  S  a
          / | \       (规则 1)
         a  S  a
          / | \       (规则 1)
         a  S  a
            |         (规则 4)
            b
```

<br/>

## 乔姆斯基范式（CNF）
**Chomsky Normal Form**  
只有所有的规则都符合以下形式，那么这个 CFG 以 CNF 表达：

1. `S -> AB`，
2. `S -> a` 或者
3. `S -> Ɛ`。

箭头的右边只能有且仅有：1. 两个非终结符，2. 一个终结符 或 3. 空字符串。

<br/>

## Cocke-Younger-Kasami (CYK) 算法
对于任意一个 CFG 和字符串 *s*，我们能确定 *s* 是否能由这个 CFG 产生。

<br/>

## 上下文无关的泵引理
我们能用上下文无关的泵引理，来**证明**一个语言**不是** CFL。

它与正则语言的泵引理差不多，但是有些不同的规则。

如果一个语言 *l* 是 CFL，那么根据 CFL 定义，*l* 会有一个用 CNF 表达的 CFG，它有 *k* 个非终结符。  
对于一个 *l* 中的单词 *w* ，它满足 `|w| >= 2^k`。  

> 如果 `k = 1`，那么 CFG 自能是 `S -> a, S-> Ɛ or S -> SS`。  
> 如果 `w > 2^k`，那么它必须会含有能形成循环的规则，如 `S -> SS` 或 `S -> AA, A -> SS`。  
> 要不然，它会只有 `S -> a, S-> Ɛ`。这个语言的单词只有：`a` 或 `Ɛ`，它们的长度都会小于 2^k。

上下文无关的泵引理的规则：
我们选一个单词 *w*（越简单越好）。
1. *w* 能被分为 *uvxyz*。（`w = uvxyz`） 
2. *v* 和 *y* 不能同时为空。（`|vy| > 0` 或 `y != Ɛ or v != Ɛ`） 
3. `|vxy| <= 2^k`。  
4. `u(v^i)x(y^i)z` 必须同时也是 *l* 中的单词，其中 `i >= 0`。（`u(v^i)x(y^i)z ∈ l`）

对于所有不同的分法，我们都需要找到一个数字 *i* 来使 `u(v^i)x(y^i)z` 不是 *l* 中的单词。

列举完所有的例子后，因为它们都与*规则4*相悖，所以我们可以进行总结：  
因为一开始的假设与结论相悖，所以语言 *l* 不是上下文无关语言。

### 例子
> 语言 `a^nb^na^n` (如：当 n = 2 时， `aabbaa`) 是上下文无关语言吗?

以 *l* 来表示语言 `a^nb^na^n`，假设 *l* 是个上下文无关语言。
所以，*l* 有个 CNF 形式的 CFG，其中有 *k* 个非终结符。
对于 *l* 中的单词 `w = a^kb^ka^k`，它满足 `|w| >= 2^k`，
那么：
1. `w = uvxyz`。
2. `|vy| > 0`。
3. `|vxy| <= 2^k`。
4. `u(v^i)x(y^i)z ∈ l`。

根据 **规则1** 和 **规则3**，`vxy` 最多只能是 `a^kb^k` 或者 `b^ka^k` 中的一个。 

对于第一种情况，`vxy = a^kb^k`、 `u = Ɛ` 和 `z = a^k`。   
`v` 能是 `a^kb^k` 或 `a^k 和一些 b` 或 `一些 a`。   
对于这 3 种情况，如果 *i* 不是 1 的话：   
前面部分 `a` 的长度会比后面部分 `a` 的长度更长（`i > 1`）或更短（`i = 0`）。  
所以 `u(v^i)x(y^i)z` 不是 *l* 中的单词。  

对于第二种情况，与第一种差不多，只是 `v` 换成了 `b^ka^k` 或 `b^k 和一些 a` 或 `一些 b`。  
所以当 *i* 不为 1 时：  
后面部分 `a` 的长度会比前面部分 `a` 的长度更长（`i > 1`）或更短（`i = 0`）。
因此 `u(v^i)x(y^i)z` 不是 *l* 中的单词。  

因为泵引理的结果与我们的假设相悖，所以语言 `a^nb^n` 不是上下文无关语言。

